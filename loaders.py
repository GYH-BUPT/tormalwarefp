import sys
import os
import json
import pandas as pd
import features_topk as ft
from sklearn.inspection import permutation_importance
from sklearn.preprocessing import MultiLabelBinarizer
from sklearn.metrics import precision_score, recall_score


######################################################################
#                        READ INPUT									 #
######################################################################
def read_value(string):
    if string[0] == "'" and string[-1] == "'":
        return string[1:-1]
    val = string
    try:
        val = int(string)
    except:
        try:
            val = float(string)
        except:
            pass
    return val

def load_options(fname):
    d_options = {}
    f = open(fname, "r")
    lines = f.readlines()
    #print(lines)
    f.close()
    for line in lines:
        ignore = 0
        if (len(line) > 0):
            if line[0] == "#":
                ignore = 1
        if (ignore == 0 and "\t" in line):
            line = line.rstrip() #[:-1]
            li = line.split("\t")
            d_options[li[0]] = read_value(li[1])
    print(d_options)
    return d_options

def get_list(d):
    # File number indices;starting 0; excluding end index
    if "MAL_START" in d.keys():
        mstart = d["MAL_START"]
        mend = d["MAL_END"]
    else:
        mstart = 0
        mend = d["MAL_TOTAL"]

    if "BEN_INSTSTART" in d.keys():
        bstart = d["BEN_INSTSTART"]
        bend = d["BEN_INSTEND"]
    else:
        bstart = mend
        bend = mend+d["BEN_INSTNUM"]

    if "MAL_INSTSTART" in d.keys():
        mistart = d["MAL_INSTSTART"]
        miend = d["MAL_INSTEND"]
    else:
        mistart = 0
        miend = d["MAL_INSTNUM"]

    if not "DATA_LOC" in d.keys():
         raise Exception("Input folder path not found in options.")
         sys.exit()

    if "HOSTFTS" in d.keys():
        if d["HOSTFTS"].lower() == "true":
            hostfts = bool(True)
        else:
            hostfts = bool(False)
    else:
        hostfts = bool(False)

    print(" ===== Hostfts Used?: ",hostfts)
    if "FOLD_TOTAL" in d:
         foldtotal = d["FOLD_TOTAL"]
    else:
         foldtotal = 10

	# 0: Binary classification; 1: Multiclass; 2: Multi class, multi target label
    if "MULTICLASS" in d:
        multi = d["MULTICLASS"] # 0: binary classification, 1: multiclass, 2: multilabel, multiclass
    else:
        multi = 0 # binary classification by default

    totalmal = (mend - mstart) * (miend+1) # Each mal instance X => X.cell & X-Y.cell; 0 <= Y < miend
    totalben = bend - bstart # Each ben instance Y => Y.cell; bstart <= Y < bend
    malfnames = []
    benfnames = []
    for (dp, dnames, fnames) in os.walk(d["DATA_LOC"]):
        for fname in fnames:
            if "-" in fname:
                if fname not in malfnames:
                   malfnames += [dp+fname]
                   print(fname+"----Malicious")
            else:
                fnum = int(fname.split(".")[0])
                if fname not in malfnames and fnum >= mstart and fnum < mend:
                    #print(fname)
                    malfnames += [dp+fname]
                    print(fname+"----Malicious")
                else:
					# Take benign data only for binary classification
                    if fname not in benfnames and fnum >= bstart and fnum < bend and multi == 0:
                        benfnames += [dp+fname]
                        print(fname+"----Benign")

    print("Malstart:%d\nMalend: %d\nBenstart:%d\nBenend:%d\n"%(mstart,mend-1,bstart, bend-1))
    readm = len(malfnames)
    readb = len(benfnames)
    if not readm == totalmal:
        print("Malware files read (%d) and options spec (%d) mismatch"%(readm, totalmal))
        #malfnames.sort()
        #print(malfnames)
    if not readb == totalben:
        print("Benign files read (%d) and options spec (%d) mismatch"%(readb, totalben))
        #benfnames.sort()
        #print(benfnames)
    print("Read:\n Malware files: %d\n Benign files:%d\n CV Folds:%d\n"%(readm, readb, foldtotal))
    return [malfnames, benfnames, foldtotal, multi, mend, miend, hostfts]


# Read AVCLASS results; map md5 hash -> sha256
def check_dependencies(d):
	if "MULTICLASS" in d:
		if d["MULTICLASS"] == 2:
			if "AVCLASS_FILE_LOC" in d:
				location = d["AVCLASS_FILE_LOC"]
			else:
				location = os.getcwd()+"avclass/AVCLASS.classes"
				if not os.path.exists(location):
					print("AVCLASS label file required for multilabel classification! : ",location)
					return False

			if "VT_REPORTS_LOC" in d:
				reportloc = d["VT_REPORTS_LOC"]
			else:
				reportloc = os.getcwd()+"avclass/reports.avclass"
				if not os.path.exists(reportloc):
					print("VT detail reports required for AVCLASS labels of malware samples!: ", reportloc)
					return False
		else:
			print("Set 'MULTICLASS = 2' in options file to run multiclass, multi label classifier\n (Mode=0 : Binary classification, Mode=1 : Multi class classification)")
			return False
	else:
		print("Can't reach here")
		return False

	return True

def getfiles(d):
	if "AVCLASS_FILE_LOC" in d:
		location = d["AVCLASS_FILE_LOC"]
	else:
		location = os.getcwd()+"avclass/AVCLASS.classes"

	if "VT_REPORTS_LOC" in d:
		reportloc = d["VT_REPORTS_LOC"]
	else:
		reportloc = os.getcwd()+"avclass/reports.avclass"

	return [location, reportloc]

def get_sha_md5map(reports="avclass/reports.avclass"):
	# Map SHA256 - md5
	md5_sha = dict()
	sha_md5 = dict()
	skipped = 0
	with open(reports, "r") as f:
		for line in f.readlines():
			datadt = json.loads(line)
			#print(datadt)
			if "data" in datadt:
				if "attributes" in datadt["data"]:
					attdt = datadt["data"]["attributes"]
					keys = attdt.keys()
					if not ("md5" in keys and "sha256" in keys):
						skipped += 1
						#print(line)
						print("No MD5/SHA hash in report , skipping....\n")
						continue
					else:
						md5 = attdt["md5"]
						sha = attdt["sha256"]
						if md5 not in md5_sha:
							md5_sha[md5] = sha
						if sha not in sha_md5:
							sha_md5[sha] = md5

	print("Not found: ", skipped)
	print("# of md5-labels read: ", len(sha_md5))
	return [md5_sha, sha_md5]

# return: sha256 malware hash: [class labels]
def read_multilabels(avclassfile, reports):
	sha_md5 = get_sha_md5map(reports)[0] # needs md5 -> sha map
	classdt = dict()

	with open(avclassfile, "r") as ff:
		for line in ff.readlines():
			if "," in line:
				line = line.replace(","," ")
			line = line.rstrip().split(" ")
			md5 = line[0]
			if line[1].isnumeric():
				labellst =  line[2:]
			else:
				labellst =  line[1:]
			#print(labellst)
			labels = labellst[0::2]
			print("Labels: ", labels)
			sha = None
			if md5 in sha_md5:
				sha = sha_md5[md5]
				if sha not in classdt:
					classdt[sha] = labels
				#else:
				#	print("Duplicate entries for sample!Skipping", sha, labels, classdt[sha])
			else:
				print("VT report not found!! Skipping sample: ", md5, labels)

			#print(md5, labels)

	print("# Samples with AVCLASS labels: ", len(classdt))
	return classdt

# Read map index file (malware hash->id)
# return: {mapi: [malware class labels, shahash]}
# NOTE: Needs "MAPFILE" location in options file
def sha_mapi(d, classdt, multiclass=False):
	sha_label_map = dict()
	uniq_labels = []
	if "MAPFILE" in d:
		fname = d["MAPFILE"]
		with open(fname, "r") as f:
			for line in f.readlines():
				line = line.rstrip().split("\t")
				shahash = line[0]
				mapi = int(line[1])
				#print(shahash, mapi)
				if not multiclass: # It is Multi label case
					labels = ["unknown"]

					if shahash in classdt.keys():
						labels = classdt[shahash] # Get multilabels
					else:
						for sha, l in classdt.items():
							if shahash in sha or shahash == sha:
								labels = l
								shahash = sha
								break
					if shahash not in sha_label_map:
						sha_label_map[mapi] = [labels, shahash]
						for lab in labels:
							if lab == "unknown":
								print(shahash)
							uniq_labels += [lab]
				else:
					# For multiclass, just return mapi-sha mapping
					if shahash not in sha_label_map:
						sha_label_map[shahash] = mapi

		#print(sha_label_map)
		print("Total Malware-AVCLASS mapping: ",len(sha_label_map))
		print("Labels in dataset: ", set(uniq_labels))
		assert len(sha_label_map) == d["MAL_TOTAL"]
	else:
		print("Aborting! Map file not available! Run cell extraction script.")
		return None
	return sha_label_map

# Return: {sha: malware family}
def get_family(sha_md5, malfamily="avclass/Malware.family"):
	sha_malfam = dict()
	md5_fam = dict()
	with open(malfamily, "r") as f:
		for line in f.readlines():
			line = line.rstrip().split("\t")
			md5 = line[0]
			fam = line[1]
			if "SINGLETON" in fam: #Just take known families for now
				continue
			print(md5, fam)
			if md5 not in md5_fam:
				md5_fam[md5] = fam

	print("Unique md5-family mapping: ", len(md5_fam))
	return md5_fam

# Get AVCLASS Malware families for multiclass labelling:
# location: ../avclass/Malware.family
def get_mal_families(d):
	mal_i_fam = dict()
	# 1. Get all hashes sha-md5 mapping
	sha_md5 = get_sha_md5map()[1] # needs sha-> md5 map
	# 2. Get sha-malware index mapping
	sha_mal_i = sha_mapi(d, sha_md5, True)
	# 3. Get family name from md5
	md5_fam = get_family(sha_md5)
	# 4. Get mal_i and family
	for sha, mal_i in sha_mal_i.items():
		#print(sha, mal_i)
		if sha in sha_md5:
			md5 = sha_md5[sha]
			if md5 in md5_fam:
				fam = md5_fam[md5]
			else:
				fam = "mal_"+str(sha_mal_i[sha])
				print("SINGLETON replaced with malware index: ", fam)
			if mal_i not in mal_i_fam:
				mal_i_fam[str(mal_i)] = fam
		else:
			print("Match for hash NotFound! : ", sha)

	print("Sha-md5 and Sha-malwareindex: ", len(sha_md5), len(sha_mal_i))
	print("Malware to family name mapping: ", len(mal_i_fam))
	return mal_i_fam

# Count malware binary-family distribution
def malware_distribution(labeldt):
	count_fam = dict()
	# k : file name, fam: [fam, malware_index]
	for k, fam in labeldt.items():
		if not "-" in k:
			if fam[0] not in count_fam:
				count_fam[fam[0]] = 1
			else:
				count_fam[fam[0]] += 1
	lst = []
	# Family- unique malware in that family
	for fam, count in count_fam.items():
		lst += [(count, fam)]
	lst.sort()
	print("Family-malware distriubtion: ", lst)
	return
######################################################################
#                        LABELLING									 #
######################################################################
# MULTICLASS: 0
def label_binary(malfnames, benfnames):
	print("Binary labelling.....")
	labeldt = dict()
	for mf in malfnames:
		if mf not in labeldt:
			labeldt[mf] = 1
			print(mf,"1")

	for bf in benfnames:
		if bf not in labeldt:
			labeldt[bf] = 0
			print(bf,"0")

	#print(labeldt)
	print("Labelled dataset: ", len(labeldt))
	# Assign labels based on file names: return: filename -> label
	return labeldt

# MULTICLASS: 1
def label_multiclass(d, malfnames, benfnames, mal_family):
	print("Multiclass labelling.......Malware family?:", mal_family)
	labeldt = dict()
	mallabels = []
	if mal_family:
		mal_i_fam = get_mal_families(d)

	for mf in malfnames:
		X = None
		fname = mf
		mf = mf.split("/")[-1].split(".")[0]
		if "-" in mf:
			X = str(mf.split("-")[0])		#X-Y.cell -> X is the malware label
		else:
			X = str(mf)						#X.cell -> X

		if fname not in labeldt:
			if mal_family:
				if X in mal_i_fam:
					fam = mal_i_fam[X]
					print("Family Multiclass Labelling: ", fname, fam)
					labeldt[fname] = [fam, X] # family name, malware binary index
				else:
					print("Don't expect to come here. All malware indices must have mapping")
					labeldt[fname] = ["mal_"+str(X), X]
			else:
				print("Binary Multiclass Labelling: ", fname, X)
				labeldt[fname] = X

		if X not in mallabels:
			mallabels += [X]

	'''
	benlabel = int(max(mallabels)) + 1
	print("Benign class label(max class): ", benlabel)
	for bf in benfnames:
		if bf not in labeldt:
			labeldt[bf] = str(benlabel)
			print("Labelling: ", bf, benlabel)
	'''
	print("Labelled dataset: ", len(labeldt))
	print("Unique malware noted: ", len(mallabels))
	if mal_family:
		malware_distribution(labeldt)

	return labeldt

def transform_labels(avlabels):
	alllabels = []
	for mi, val in avlabels.items():
		labels = val[0]
		for lab in labels:
			if lab not in alllabels:
				alllabels.append(lab)
	#print(alllabels)
	uniqlabels = list(set(alllabels))
	print(uniqlabels)
	mlb = MultiLabelBinarizer()
	mlb.fit([uniqlabels])
	print("MULTI LABEL CLASSES: ",mlb.classes_)
	#print(result)
	return [mlb, mlb.classes_]

def generate_multilabel(elements, mlb, classorder):
	multilabel = mlb.transform([elements])
	print(elements, multilabel)
	print(type(multilabel))
	return multilabel

# MULTICLASS: 2
def label_multiclass_multilabel(malfnames, benfnames, avlabels):
	# avlabels-> {'malware mapindex/X in X-Y.cell': [avclass labels, sha]}
	print("Multiclass Multilabelling.......")
	labeldt = dict()
	mallabels = []
	# Get multiclass labels from avclass labels
	[mlb, classorder] = transform_labels(avlabels)

	for mf in malfnames:
		X = None
		fname = mf
		mf = mf.split("/")[-1].split(".")[0]
		if "-" in mf:
			X = int(mf.split("-")[0])		#X-Y.cell -> X is the malware label
		else:
			X = int(mf)						#X.cell -> X
		print("Labelling: ", fname, X)
		if fname not in labeldt:
			if X in avlabels:
				labeldt[fname] = generate_multilabel(avlabels[X][0], mlb, classorder)
			else:
				print("Label for malware index: %d not available! Check mapping!"%X)
		if X not in mallabels:
			mallabels += [X]

	'''
	benlabel = int(max(mallabels)) + 1
	print("Benign class label(max class): ", benlabel)
	for bf in benfnames:
		if bf not in labeldt:
			labeldt[bf] = benlabel
			print("Labelling: ", bf, benlabel)
	'''
	#generate_multilabel(avlabels[X][0], mlb, classorder)
	print("Labelled dataset: ", len(labeldt))

	return [labeldt, classorder, mlb]

######################################################################
#                        FEATURE EXTRACTION							 #
######################################################################
def get_topk_conn_cells(data, topk=3):
	topkconns = []
	torconn1 = []
	torconn2 = []
	torconn3 = []
	for line in data:
		if "1#" in line:
			torconn1 += [line.split("#")[1]]

		elif "2#" in line and topk >= 2:
			torconn2 += [line.split("#")[1]]

		elif "3#" in line and topk == 3:
			torconn3 += [line.split("#")[1]]

		elif "HOSTFTS" in line:
			continue

	#print("T1: ", torconn1)
	t1 = len(torconn1)
	t2 = len(torconn2)
	t3 = len(torconn3)
	print("Top 3 Tor connection cells noted: ", t1, t2, t3)
	if t1 > 0 and t2 > 0 and t3 > 0:
		topkconns += [torconn1, torconn2, torconn3]
	elif t2 == 0:
		topkconns = [torconn1]
	elif t2 > 0 and t3 == 0:
		topkconns = [torconn1, torconn2]

	#print("Topkconns: ", topkconns)
	return topkconns

def extract_features(labeldt, multiclass, hostfts, top=3, classorder=[], malfamily=False, trainmulti=True):
	feats = []
	c = 0
	totalcols = []
	topkcount = []
	print("Extracting features for Classification Mode: ", multiclass)
	print("Host fts switch active?: ", hostfts)
	all_multilabels = []
	famcount = dict()

	for fpath, label in labeldt.items():
		print("*",fpath, label)
		data = open(fpath).readlines()
		print(top)
		topkconns = get_topk_conn_cells(data, top)
		print("Taking Top: ", len(topkconns))
		topkcount += [len(topkconns)]
		if len(topkconns) == 0:
			continue
		for conndata in topkconns: # Save Fts:label in DF for each conn in topk
			tcp_dump = conndata #[:101] # just take 1st 100 cells
			#if hostfts and "##HOST_FTS" not in tcp_dump:
			#	tcp_dump += [str(data[-1])]
			#	print("Host fts added: ", data[-1])
			print("TCPDUMP CELLS: ", len(tcp_dump))
			fts = []
			print(fpath)
			fts = ft.TOTAL_FEATURES(tcp_dump, False) #Keep bool vals for topk
			if hostfts:
				# Extract only host fts here
				Hfts = ft.TOTAL_FEATURES(data, False, True)
				print("Host fts: ", Hfts)
				assert len(Hfts) > 0
				fts += Hfts
				assert len(fts) == 215
				print("Full fts: ", fts)

			totalcols += [len(fts)]
			print("Extracting features: ", fpath, label)

			# Multi class classification
			if multiclass == 1:
				print("Multi class: label :", label)
				fam = label[0]
				if malfamily: # balance family-instances
					mali = label[1]
					print("Malware families used for multi class labels")
					if fam not in famcount:
						famcount[fam] = [mali]
					else:
						if len(famcount[fam]) < 6 and mali not in famcount[fam]:
							famcount[fam] += [mali]
					fam_malcount = len(famcount[fam])
					if fam == "agentb" or fam == "shade" or fam == "nymeria":
						# Take only 6 unique binaries / max no. class binaries and instances
						if fam_malcount <= 6 and mali in famcount[fam]:
							feats += [fts+[fam]]
					else:
						feats += [fts+[fam]]
				else:
					# Normal multiclass case
					feats += [fts+[fam]]
					print("Normal multiclass", fts)

			# Multi label classification
			elif multiclass == 2:
				if trainmulti:
					all_multilabels += list(label)
				else:
					all_multilabels += [label]
				feats += [fts]
			else:
				# binary classification
				feats += [fts+[label]]

	print("Total features: ", max(totalcols))
	#print(feats)
	print("Total files for which features extracted: ", len(feats))
	#print(all_multilabels)
	featdf = pd.DataFrame(feats)
	##print("Topk connection distribution per file: ", topkcount.sort())
	if multiclass == 2:
		#featdf['target'] = [l[0] for l in featdf['target']]
		if list(classorder) == [] and trainmulti:
			print("Classorder needed to set labels in DF!")
			return None
		else:
			if not trainmulti: # Return just features for testing
				labeldf = pd.DataFrame(all_multilabels)
				fullfeatdf = pd.concat([featdf, labeldf], axis=1)
				fullfeatdf.columns = [*fullfeatdf.columns[:-1], 'binary']
				return fullfeatdf
			labeldf = pd.DataFrame(all_multilabels) #,columns=list(classorder))
			labeldf.columns = list(classorder)
			featdff = pd.concat([featdf, labeldf], axis=1)
			print("Multi Label df:\n", labeldf)
			print("Final multi label df:\n", featdff)
			print("DF Size and shape: ", featdff, featdff.shape)
			return [featdff, len(featdf.columns)]
	else:
		if multiclass == 1 and malfamily:
			print("Balanced family-instances: ", famcount)

		featdf.columns = [*featdf.columns[:-1], 'target']
		print("DF Size and shape: ", featdf, featdf.shape)
		if multiclass == 0:
			malrows = featdf[featdf['target'] == 1]
			benrows = featdf[featdf['target'] == 0]
			print("Malrows: ", malrows.shape, " Benrows: ", benrows.shape)
		return featdf

######################################################################
#                     PERFORMANCE EVALUATION					     #
######################################################################
def evaluate_model(y_test, y_pred, probs, multiclass=False):
    results = {}
    if multiclass:
        results['recall'] = recall_score(y_test, y_pred, average='micro')
        results['precision'] = precision_score(y_test, y_pred, average='micro')
    else:
        results['recall'] = recall_score(y_test, y_pred)
        results['precision'] = precision_score(y_test, y_pred)
    #results['roc'] = roc_auc_score(y_test, probs)
    print("Micro Recall: ", results['recall'])
    print("Micro Precision: ", results['precision'])
    #print("ROC/AUC Score: ", results['roc'])
    '''
	baseline = {}
    baseline['recall']=recall_score(y_test,
                    [1 for _ in range(len(y_test))])
    baseline['precision'] = precision_score(y_test,
                    [1 for _ in range(len(y_test))])
    baseline['roc'] = 0.5
	'''
    return results


def sklearn_featimpo(model):
	print("====SKLEARN Feature Importance====")
	importance = model.feature_importances_
	# summarize feature importance
	for i,v in enumerate(importance):
		print('Feature: %0d, Score: %.5f' % (i,v))
		# plot feature importance
	return

def permute_fimp(model, X, y):
	print("==== Permutation Feature Importance =====")
	# perform permutation importance
	results = permutation_importance(model, X, y, scoring='accuracy')
	# get importance
	importance = results.importances_mean
	importance.sort()
	# summarize feature importance
	for i,v in enumerate(importance):
		print('Feature: %0d, Score: %.5f' % (i,v))
	return

def write_output(ff, score, tp, fp, tn, fn, results):
	prec = str(results['precision'])
	recall = str(results['recall'])
	ff.write(str(score)+"\t"+str(tp)+"\t"+str(fp)+"\t"+str(tn)+"\t"+str(fn)+"\t")
	ff.write(prec+"\t"+recall+"\n")
	return ff

def output_avg(ag_res1, ag_res2, fimp1, fimp2, auto_cmatrix, perf, perfstack, ff):
	ff.write("-----------------Autogluon----------------\n")
	ff.write("Best model confusion matrix: \n")
	[tn,fp,fn,tp] = auto_cmatrix
	prec = tp/(tp+fp)*100.0
	recall = tp/(tp+fn)*100.0
	ff.write("TN: "+str(tn)+" FP: "+str(fp)+" FN: "+str(fn)+" TP: "+str(tp)+"\n")
	ff.write("Precision: "+str(prec)+"% \n"+"Recall: "+str(recall)+"% \n")
	ff.write("::Model performance on test data::\n")
	ff.write(str(perf)+"\n")
	ff.write(str(ag_res1))
	ff.write("*Ft impo*\n")
	#print(type(fimp1))
	ff.write(str(fimp1)+"\n")
	ff.write("\n::Stacking & Weighted Ensembling of Models::\n")
	ff.write(str(perfstack)+"\n")
	ff.write(str(ag_res2))
	ff.write("*Ft impo*\n")
	ff.write(str(fimp2)+"\n")
	ff.write("--------------------------------------------\n")
	ff.close()
	return

def output_multilabel(mllabel_op, outfolder, malinst, hostfts, topk):
	fname = "top_"+str(topk)+"_"+str(malinst)+"_"
	if hostfts:
		fname += "host_"
	ff = open(outfolder+fname+"malwareclass.score", "a+")
	techniques = ["BinaryRelevance-RF", "Classifier Chains- RF", "Label Powerset- RF"]
	i = 0
	assert len(techniques) == len(mllabel_op)
	for res in mllabel_op:
		acc= str(res[0])
		hloss= str(res[1])
		mprec= str(res[2])
		mrecall= str(res[3])
		mf1= str(res[4])
		modeltype= res[5]
		technique = techniques[i]
		ff.write("Technique: %s, Model: %s\n\n"%(technique, modeltype))
		ff.write("Accuracy: %s; Hamming Loss: %s; Micro-Prec: %s; Micro-Recall: %s; Micro-F1: %s\n\n\n"%(acc, hloss, mprec, mrecall, mf1))
		i += 1
	return
